<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0064)https://web.cs.ucla.edu/classes/fall21/cs31/Projects/3/spec.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
 <title>CS 31 Project 3, Fall 2021</title>
</head>
<body data-new-gr-c-s-check-loaded="14.1041.0" data-gr-ext-installed="">
<div align="right">
Fall 2021 CS 31
</div>
<div align="center">
<h2>Programming Assignment 3<br>
Grid Game</h2>
<p>
<strong>Time due: 11:00 PM Wednesday, October 27</strong>
</p>
</div>
<!--
<p style="font-size: smaller">
Before you ask a question about this specification, see if it has already
been addressed by the <a href="faq.html">Project 3 FAQ</a>.  And read the
FAQ before you turn in this project, to be sure you didn't misinterpret
anything.
</p>
-->
<h3>Introduction</h3>
<p>
You and hundreds of other people are stuck on an island where you must
compete in deadly games.  In the current game, you are strapped into a
robot car that will navigate a maze to reach a goal.  You must provide
the car with a navigation plan beforehand and can not change it once your
ride begins.  If the car reaches the goal after obeying the instructions
in the plan within a certain time, you survive; if it crashes into a wall,
…
</p><p>
Fortunately, you have come across a computer with a C++ compiler
installed, so you can write a program to help you verify that your
proposed plan is properly formed and will safely get you to the goal. 
</p><p>
The maze is represented by a rectangular grid of up to 25 rows and up to
30 columns.  Each cell of the grid is either empty or occupied by a wall. 
Here is a small example:
</p>
<pre>	   1234
	 1 ...*
	 2 .*..
	 3 .*..
</pre>
<p>
In this example, there are three rows and four columns.  There are walls
at (1,4), (2,2), and (3,2).  (The notation <em>(r,c)</em> means the cell
at row r, column c.)  If the car is at an empty cell, it can move only to
an empty cell adjacent to it in one of the four cardinal directions
(north, east, south, and west).  Following usual map conventions,
<em>north</em> means in the direction of decreasing row numbers,
<em>east</em> is in the direction of increasing column numbers, etc.  In
our model, we assume that there are walls all around the grid, so that a
car at (2,4) is blocked from moving east.  In the example above, a car at
the empty cell (1,2) could move west to (1,1) or east to (1,3); it could
not move south to (2,2), because there's a wall there, nor could it move
north, since the assumed wall around the grid blocks it.
</p><p>
Let's define a <em>turn letter</em> as by one of the two letters R or L,
in either upper or lower case, and a <em>direction letter</em> as one of
the four letters N, E, W, or S, in either upper or lower case.  We define
a <em>plan portion</em> as zero, one, or two digits, followed by a turn
letter.  Examples are L and 2R and 13L.  A <em>plan</em> is a sequence of
zero or more plan portions (not separated or surrounded by spaces, commas,
or anything else; every character in a non-empty plan must be part of a
portion).  An example of a plan is LL2R2r2L1R.  Given a start position and
a start direction the car is facing, an <em>obeyable plan</em> is a plan
that the car could obey from start to end without starting on or trying to
move to a cell containing a wall.  By <em>obeying</em> a plan, we mean
interpreting the plan portions, in order, as instructions to move the
specified number of steps forward in the direction the car is facing, then
rotating the car 90 degrees as instructed by the turn letter: 
right/clockwise for R, left/counterclockwise for L.  A turn letter
preceded by no digits means to not move the car any steps, but simply
rotate it as instructed.  As for a plan portion with two digits, the plan
portion <code>13R</code>, for example, means to move 13 steps forward and
then rotate right.)
</p><p>
As an example, in the grid shown above, if the start position is (3,1) and
the car s facing south, then LL2R02LR0r2L1R is an obeyable plan:  The car
is directed to turn left (so it now faces east), turn left (so it now faces
north), move forward 2 steps and turn right (so it's now at (1,1) facing
east), move forward 2 steps and turn left (so it's now at (1,3) facing
north), turn right (so it now faces east), move 0 steps and turn right
(so it's still at (1,3), but now facing south), move forward 2 steps and
turn left (so it's now at (3,3) facing east), and move forward 1 step and
turn right (so it's now at (3,4) facing south.  This plan is obeyable, since
it never directs a car into a wall grid point or off the grid.  (An
obeyable plan that for the same starting conditions would end up at the
same place without making any unnecessary turns would be LL2R2r2L1R.)
From the same starting position and direction, none of these are obeyable
plans:  1R (goes off the grid), LL3R (goes off the grid), L3R (moves into
a wall), LL2R3r2L (moves into a wall).  Starting from (2,2) there are no
obeyable plans, since (2,2) itself is a wall.  The string R0FL is not an
obeyable plan because it is not even a plan:  it doesn't fit the definition
of a plan.
</p>
<h3>Your task</h3>
<p>
For this project, you will implement the following three functions, using
the exact function names, parameter types, and return types shown in this
specification.  (The parameter <em>names</em> may be different if you wish.)
</p><dl>
<dt><code>bool hasCorrectForm(string plan)</code></dt>
<dd><p>
This function returns true if its parameter is a plan (i.e., it meets the
definition above).  Here are two strings that are plans:  5rL00L0R09R7L
and 42l (the last character of the latter is a lower case L).  Here are
four strings that are not plans:  L2, 1Rx2L, 144R, 1R+2L.  N144, and
w2+n3.  Notice that a string may be a plan without being obeyable in a
particular grid.  (This is analogous to the sentence "Travel east on
Wilshire Blvd. until you come to the first signal past Sunset Blvd." being
syntactically correct English, but not obeyable in Los Angeles, since
Wilshire never intersects Sunset.)
</p></dd>
<dt><code>int determineSafeDistance(int r, int c, char dir, int maxSteps)</code></dt>
<dd><p>
This function determines the number of steps a car starting at position
(<code>r</code>,<code>c</code>) could travel in the direction indicated by
<code>dir</code>.  In the normal case, when this function is called,
(<code>r</code>,<code>c</code>) is an empty grid position, <code>dir</code>
is a direction letter, and <code>maxSteps</code> is the proposed number of
steps to travel in the indicated direction.  In this case, if the car
starting at (<code>r</code>,<code>c</code>) could indeed travel that
number of steps in that direction without moving to a grid point
containing a wall or running off the edge of the grid, then the function
returns that number of steps; otherwise, the function returns the maximum
number of valid steps in that direction the car could travel (which will
be less than the value of <code>maxSteps</code>, and might even be zero). 
If (<code>r</code>,<code>c</code>) is not a valid empty grid position, or
if <code>dir</code> is not a direction letter, or if <code>maxSteps</code>
is negative, the function returns &#8722;1.
</p></dd>
<dt><code>int obeyPlan(int sr, int sc, int er, int ec, char dir, string plan, int&amp; nsteps)</code></dt>
<dd><p>
This function determines the number of steps a car starting at position
<code>sr</code>,<code>sc</code>) and initially facing in the direction
indicated by <code>dir</code> travels when obeying the indicated plan,
which should lead to the end position (<code>er</code>,<code>ec</code>).
In the normal case, (<code>sr</code>,<code>sc</code>) and
(<code>er</code>,<code>ec</code>) are empty grid positions,
<code>dir</code> is a direction letter, and <code>plan</code> is an
obeyable plan.  In this case, the function sets <code>nsteps</code> to the
number of steps a car starting at (<code>sr</code>,<code>sc</code>)
initially facing in direction <code>dir</code> travels when obeying the
complete plan, and returns 0 if the car ends up at
(<code>er</code>,<code>ec</code>), or 1 otherwise.  If
(<code>sr</code>,<code>sc</code>) or (<code>er</code>,<code>ec</code>) are
not valid empty grid positions or if <code>dir</code> is not a direction
letter or if the <code>plan</code> string is not a plan, the function
returns 2 and leaves <code>nsteps</code> unchanged.  If
(<code>sr</code>,<code>sc</code>) and (<code>er</code>,<code>ec</code>)
are empty grid positions and <code>dir</code> is a direction letter and
the <code>plan</code> string is a plan, but the car could not obey the
complete plan without moving to a cell containing a wall or running off
the edge of the grid, then the function returns 3 and sets
<code>nsteps</code> to the maximum number of steps that the car can travel
(which might be 0) obeying the plan until it tries to move to a cell
containing a wall or off the grid (which might be 0).  The function must
<em>not</em> assume that <code>nsteps</code> has any particular value at
the time this function is entered.
</p></dd>
</dl>
<p>
These are the only three functions you are required to write.  (Hint:
<code>obeyPlan</code> may well call the other two functions.)  Your
solution may use functions in addition to these three if you wish.  While
we won't test those additional functions separately, using them may help you
structure your program more readably.
</p><p>
Of course, to test the functions you write, you'll want to write a main
routine that creates a grid and calls your functions.  During the course
of developing your solution, you might change that main routine many
times. As long as your main routine compiles correctly when you turn in
your solution, it doesn't matter what it does, since we will rename it to
something harmless and never call it (because we will supply our own main
routine to thoroughly test your functions).
</p><p>
To help you write your functions, we have provided <code>getRows</code>, 
<code>getCols</code>, and <code>isWall</code> routines that you may call to
determine properties of the grid.  They're described in the
<a href="https://web.cs.ucla.edu/classes/fall21/cs31/Projects/3/gridlibrary.html">Project 3 Grid Library</a> writeup, along with
<code>setSize</code> and <code>setWall</code> routines you'll want to use in
your main routine to set up a test grid, and <code>draw</code> routines you
may want to use to help you visualize what's going on.  Make sure you never
call any of these routines with invalid arguments, because if you do, it will
abruptly terminate your program after writing an error message.
</p><p>
All the code you write will be in the file <code>gridgame.cpp</code>.  The
routines we provide are in the files <code>grid.h</code> and
<code>grid.cpp</code>.  You will turn in only <code>gridgame.cpp</code>, so
don't make any changes to <code>grid.h</code> or <code>grid.cpp</code>,
since we will never see any such changes.  (We'll use our own versions
when testing your code.)
</p>
<h3>Programming Guidelines</h3>
<p>
The functions your write must not use any global variables whose values
may be changed during execution.  Global <em>constants</em> are allowed.
</p><p>
When you turn in your solution, none of the three required functions, nor
any functions you write that they call, may read any input from
<code>cin</code> or write any output to <code>cout</code>.  (Of course,
during development, you may have them write whatever you like (perhaps by
calling <code>draw</code>) to help you debug.)  If you want to print
things out for debugging purposes, write to <code>cerr</code> instead of
<code>cout</code>.  <code>cerr</code> is the standard error destination;
items written to it by default go to the screen.  When we test your
program, we will cause everything written to <code>cerr</code> to be
discarded instead — we will never see that output, so you may leave
those debugging output statements in your program if you wish.  (Note that
the <code>draw</code> functions write to <code>cerr</code>, not
<code>cout</code>.)
</p><p>
The correctness of your program must not depend on undefined program behavior.
Your program must never access out of range positions in a string.  Your
program must not, for example, assume anything about <code>n</code>'s
value at the point indicated, or even whether or not the program crashes:
</p>
<pre>	int main()
	{
	    string s = "Hello";
	    int n;              // n is uninitialized
	    s.at(5*n/n) = '!';  // undefined behavior!
	    …
</pre>
<p>
Be sure that your program builds successfully, and try to ensure that your
functions do something reasonable for at least a few test cases under both
g31 and either Visual C++ or clang++.  That way, you can get some partial
credit for a solution that does not meet the entire specification.
</p>
<p>
There are a number of ways you might write your main routine to test your
functions.  One way is to interactively accept test strings:
</p>
<pre>	int main()
	{
    	    setSize(3,4);
    	    setWall(1,4);
    	    setWall(2,2);
    	    setWall(3,2);
	    for (;;)
	    {
	        cout &lt;&lt; "Enter plan: ";
	        string p;
		getline(cin, p);
		if (p == "quit")
		    break;
		cout &lt;&lt; "hasCorrectForm returns ";
		if (hasCorrectForm(p))
		    cout &lt;&lt; "true";
		else
		    cout &lt;&lt; "false";
		cout &lt;&lt; endl;
	    }
	}
</pre>
<p>
While this is flexible, you run the risk of not being able to reproduce
all your test cases if you make a change to your code and want to test
that you didn't break anything that used to work.
</p><p>
Another way is to hard-code various tests and report which ones the program
passes:
</p>
<pre>	int main()
	{
    	    setSize(3,4);
    	    setWall(1,4);
    	    setWall(2,2);
    	    setWall(3,2);
	    if (hasCorrectForm("2R1r"))
		cout &lt;&lt; "Passed test 1: hasCorrectForm(\"2R1r\")" &lt;&lt; endl;
	    if (!hasCorrectForm("1Lx"))
		cout &lt;&lt; "Passed test 2: !hasCorrectForm(\"1Lx\")" &lt;&lt; endl;
	    if (determineSafeDistance(3, 1, 'N', 2) == 2)
		cout &lt;&lt; "Passed test 3: determineSafeDistance(3, 1, 'N', 2)" &lt;&lt; endl;
	    int len;
	    len = -999;  // so we can detect whether obeyPlan sets len
	    if (obeyPlan(3,1, 3,4, 'S', "LL2R2r2L1R", len) == 0  &amp;&amp;  len == 7)
		cout &lt;&lt; "Passed test 4: obeyPlan(3,1, 3,4, 'N', \"LL2R2r2L1R", len)" &lt;&lt; endl;
	    len = -999;  // so we can detect whether obeyPlan sets len
	    if (obeyPlan(3,1, 3,4, 'N', "1Lx", len) == 2  &amp;&amp;  len == -999)
		cout &lt;&lt; "Passed test 5: obeyPlan(3,1, 3,4, 'N', \"1Lx\", len)" &lt;&lt; endl;
	    len = -999;  // so we can detect whether obeyPlan sets len
	    if (obeyPlan(2,4, 1,1, 'w', "3R1L", len) == 3  &amp;&amp;  len == 1)
		cout &lt;&lt; "Passed test 6: obeyPlan(2,4, 1,1, 'w', \"3R1L\", len)" &lt;&lt; endl;
	    …
</pre>
<p>
This can get rather tedious.  Fortunately, the library has a facility to
make this easier: <code>assert</code>.  If you #include the header
<code>&lt;cassert&gt;</code>, you can call <code>assert</code> in the
following manner:
</p>
<pre>	assert(<em>some boolean expression</em>);
</pre>
<p>
During execution, if the expression is true, nothing happens and execution
continues normally; if it is false, a diagnostic message is written to
<code>cerr</code> telling you the text and location of the failed
assertion, and the program is terminated.  Using <code>assert</code>, we
can write the tests above more easily:
</p><pre>	#include &lt;iostream&gt;
	#include &lt;cassert&gt;
	using namespace std;

	bool hasCorrectForm(string plan)
	{
	    <em>… Your code goes here …</em>
	}

	int determineSafeDistance(int r, int c, char dir, int maxSteps)
	{
	    <em>… Your code goes here …</em>
	}

	int obeyPlan(int sr, int sc, int er, int ec, char dir, string plan, int&amp; nsteps)
	{
	    <em>… Your code goes here …</em>
	}

	int main()
	{
    	    setSize(3,4);
    	    setWall(1,4);
    	    setWall(2,2);
    	    setWall(3,2);
	    assert(hasCorrectForm("2R1r"));
	    assert(!hasCorrectForm("1Lx"));
	    assert(determineSafeDistance(3, 1, 'N', 2) == 2);
	    int len;
	    len = -999;  // so we can detect whether obeyPlan sets len
	    assert(obeyPlan(3,1, 3,4, 'S', "LL2R2r2L1R", len) == 0  &amp;&amp;  len == 7);
	    len = -999;  // so we can detect whether obeyPlan sets len
	    assert(obeyPlan(3,1, 3,4, 'N', "1Lx", len) == 2  &amp;&amp;  len == -999);
	    len = -999;  // so we can detect whether obeyPlan sets len
	    assert(obeyPlan(2,4, 1,1, 'w', "3R1L", len) == 3  &amp;&amp;  len == 1);
	    …
	    cerr &lt;&lt; "All tests succeeded" &lt;&lt; endl;
	}
</pre>
<p>
The reason for writing one line of output at the end is to ensure that you
can distinguish the situation of all tests succeeding from the case where one
function you're testing silently crashes the program.
</p>
<h3>What to turn in</h3>
<p>
What you will turn in for this assignment is a zip file containing these
two files and nothing more:
</p>
<ol>
<li>
<p>
A text file named <strong>gridgame.cpp</strong> that contains the source
code for your C++ program.  Your source code should have helpful comments
that tell the purpose of the major program segments and explain any tricky
code.  A project that contains your <code>gridgame.cpp</code>, our
<code>grid.cpp</code> and our <code>grid.h</code> must be able to be built
and run, so <code>gridgame.cpp</code> must contain appropriate #include
lines, a main routine, and any additional functions you may have chosen to
write.
</p>
</li>
<li>A file named <strong>report.docx</strong> or <strong>report.doc</strong>
(in Microsoft Word format) or <strong>report.txt</strong> (an ordinary
text file) that contains:
<ol style="list-style: lower-alpha">
<li>A brief description of notable obstacles you overcame.
</li>
<li>A description of the design of your program.  You should use
<a href="https://web.cs.ucla.edu/classes/fall21/cs31/pseudocode.html">pseudocode</a> in this description where it
clarifies the presentation.
</li>
<li>
A list of the test data that could be used to thoroughly test your
program, along with the reason for each test.  You don't have to include
the results of the tests, but you must note which test cases your program
does not handle correctly.  (This could happen if you didn't have time to
write a complete solution, or if you ran out of time while still debugging
a supposedly complete solution.)  If you use the <code>assert</code> style
above for writing your test code, you can copy those <code>assert</code>s,
along with a very brief comment about what each is testing for.  Notice
that most of this portion of your report can be written just after reading
the requirements in this specification, before you even start designing
your program.
</li>
</ol>
</li>
</ol>
<p>
Your zip file must <em>not</em> contain the <code>grid.h</code> and
<code>grid.cpp</code> files that we supply.  When we test your program, we
will use our own versions of these files that are specially instrumented
for automated testing.
</p>
<p>
By October 26, there will be links on the class webpage that will enable you
<!--
The <a href="../../Submit/submission.cgi?asst=3">turn in Project 3</a>
link on the class webpage enables you
-->
to turn in your zip file electronically.  Turn in the file by the due time
above.  Give yourself enough time to be sure you can turn something in.
There's a lot to be said for turning in a preliminary version of your
program and report early (You can always overwrite it with a later
submission).  That way you have something submitted in case there's a
problem later.
</p>


</body><grammarly-desktop-integration data-grammarly-shadow-root="true"></grammarly-desktop-integration></html>